grammar org.xtext.example.mydsl.Uml with org.eclipse.xtext.common.Terminals

generate uml "http://www.xtext.org/example/mydsl/Uml"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// TODO
/*
 * Add modifiers management on umlObjects
 * Add modifier static to functions
 */


Program:
	(code+=Statement)*;

Statement:
	Link | UmlObject | Package;
	
	
// LINKS
Link:
	Heritage | Implementation | Relation; 


Relation:
	StrongAggregation | Association;

	
Implementation: 
	'implementation' '(' motherClass=ID ',' childrenClass=ID ')' ';'
;
	
Heritage:
	'heritage' '(' superClass=ID ',' childrenClass=ID ')' ';'
;


// Voir si on a d'autres paramètres ou des paramètres vides
Association: 
	'association' '(' nameClass1=ID ',' nameClass2=ID ',' nameLiaison=ID ',' quantity1=INT ',' quantity2=INT ')' ';'
;

StrongAggregation:
	'strongAssociation' '(' nameClass1=ID ',' nameClass2=ID ',' nameLiaison=ID ',' quantity2=INT ')' ';'
;


// OBJECTS
UmlObject: 
	Class | AbstractClass | Interface | Enum;
	




// Keep the parameter and the function
Class: 'class' name=ID '{'
    'parameter' '{'
        (params+=DefinedParameter)*
    '}'
    'function' '{'
        (functions+=Function)*
    '}'
'}';



AbstractClass: 'abstract' 'class' name=ID '{'
	'parameter' '{'
		(params+=DefinedParameter)*
	'}'
	'function' '{'
		(functions+=AbstractFunction)*
	'}'
'}'
;


// https://www.uml-diagrams.org/class-reference.html
Interface: 'interface' name=ID '{'
	'function' '{'
		(functions+=InterfaceFunction)
	'}'
'}'
;




// Definition of a parameter 
DefinedParameter: StaticParameter | ClassicParameter;

StaticParameter: visibility=VISIBILITY 'static' modifier=MODIFIER? type=TYPE name=ID ';';

ClassicParameter: visibility=VISIBILITY modifier=MODIFIER? type=TYPE name=ID ';';



 
// TODO :: Pour te type, penser que l'on peut avoir une class et pas seulement que des type primitif
FunctionParameter: visibility=VISIBILITY? modifier=MODIFIER? type=TYPE name=ID;


// TODO :: Peut-être merger les différentes function en une seul ? 
// Here * --> 0 or more
Function: visibility=VISIBILITY returnType=TYPE name=ID'(' 
	(params+=FunctionParameter ','?)* 	
')' ';';

AbstractFunction: visibility=VISIBILITY 'abstract'? returnType=TYPE name=ID'(' 
	(params+=FunctionParameter ','?)* 	
')' ';'
;

InterfaceFunction: visibility=VISIBILITY returnType=TYPE name=ID'(' 
	(params+=FunctionParameter ','?)* 	
')' ';';


Enum: 'enum' name=ID '{' 
	(params+=EnumConstante)+	
'}';


EnumConstante: name=ID ';';



// PACKAGE
// TODO :: Je crois que l'on doit rajouter dans le style que le nom du package doit être définie soit pas une classe ou un nom de package précédement créé.
Package: 'package' name=ID '{' 
	(packageName+=ID ','?)+
'}';




VISIBILITY returns ecore::EChar: 
	'+' | '-' | '#' | '~';

MODIFIER returns ecore::EString:
	'final' | 'const';

TYPE returns ecore::EString:
	'string' | 'String' | 'int' | 'boolean' | 'long' | 'void'
;


	